<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <style>
  body {
    font: 10px sans-serif;
  }

  rect.bordered {
    stroke: #E6E6E6;
    stroke-width:2px;   
  }
  .chart {
    position: fixed;
    top: 0px;
    left: 0px;
  }

  .tbox {
    position: fixed;
    top: 0px;
    left: 900px;
    background-color: grey;
    width: 300px;
    height: 500px;
  }

  </style>
  <script src="http://d3js.org/d3.v3.js"></script>
  <script src="http://d3js.org/colorbrewer.v1.min.js"></script>
</head>
<body>
<div class='chart' id="chart"></div>
<div class='tboxx' id="tbox"></div>

<script type="text/javascript">
var margin = { top: 50, right: 0, bottom: 100, left: 100 },
    width = 900 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom,
    gridSize = Math.floor(width / 13),
    legendElementWidth = gridSize*1.3,
    buckets = 70,
    // colors = colorbrewer.Reds[9]
    // colors = colorbrewer.Purples[9]
    colors = colorbrewer.BuPu[9]
    // colors = colorbrewer.YlGnBu[9]
    // colors = colorbrewer.Reds[9]
    // colors = colorbrewer.OrRd[9]
    // colors = colorbrewer.Greens[9]
    // colors = colorbrewer.Blues[9]
    greycolors = colorbrewer.Greys[9]
    estimators = ['linear', 'knn', 'logistic', 'gaussian', 'svc', 'decision tree', 'random forest'],
    features = ['age', 'sex', 'chest pain', 'resting bp', 'cholesterol',
            'blood sugar', 'ecg', 'max hr', 'angina',
            'depression', 'slope', 'vessels', 'thal'],
    ys = ['linear', 'knn', 'logistic', 'gaussian', 'svc', 'decision_tree', 'random_forest'],
    xs = ['age', 'sex', 'chest_pain', 'resting_bp', 'cholesterol',
            'blood_sugar', 'ecg', 'max_hr', 'exercise_induced_angina',
            'st_depression', 'slope', 'num_major_vessels', 'thal'];

// Randomly Shuffle Array
function shuffle(array) {
    var currentIndex = array.length, temporaryValue, randomIndex ;
    while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
    }
    return array;
}

d3.tsv("cleveland_data.csv",
  function(d) {
    return {
      estimator: ys.indexOf(d.Estimator),
      feature: xs.indexOf(d.Feature),
      value: +d.Accuracy * 100
    };
  },

  function(error, data) {
    var colorScale = d3.scale.quantile()
        .domain([20, buckets, d3.max(data, function (d) { return d.value; })])
        .range(colors);
    var greyScale = d3.scale.quantile()
        .domain([20, buckets, d3.max(data, function (d) { return d.value; })])
        .range(greycolors);

    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var estimatorLabels = svg.selectAll(".estimatorLabel")
        .data(estimators)
        .enter().append("text")
          .text(function (d) { return d; })
          .attr("x", 0)
          .attr("y", function (d, i) { return i * gridSize; })
          .style("text-anchor", "end")
          .attr("transform", "translate(-6," + gridSize / 1.5 + ")");

    var featureLabels = svg.selectAll(".featureLabel")
        .data(features)
        .enter().append("text")
          .text(function(d) { return d; })
          .attr("x", function(d, i) { return i * gridSize; })
          .attr("y", 0)
          .style("text-anchor", "middle")
          .attr("transform", "translate(" + gridSize / 2 + ", -6)");

    heatMap = svg.selectAll(".box")
        .data(data)
        .enter().append("rect")
          .attr("x", function(d) { return (d.feature) * gridSize; })
          // .attr("y", function(d) { return (d.estimator - 10) * gridSize; })
          .attr("y", function(d) { return (d.estimator + 1) * gridSize * -1; })
          // .attr("y", -100)
          .attr("rx", 4)
          .attr("ry", 4)
          .attr("class", function(d) { return "box bordered " + xs[d.feature]; } )
          .attr("width", gridSize)
          .attr("height", gridSize)
          .style("fill", function(d) { return colorScale(d.value); });
          // .style("fill", colors[0]);

    var selection_rectangle = svg.selectAll(".selector")
      .data(xs)
      .enter().append("rect")
        .attr("x", function(d, i) { return i * gridSize; })
        .attr("y", -20)
        .attr("rx", 4)
        .attr("ry", 4)
        .attr("width", gridSize)
        .attr("height", 447)
        .style("opacity", 0.5)
        .style("stroke-opacity", 1.0)
        .style("fill-opacity", 0.0)
        .style("fill", 'purple')
        .style("stroke", 'black')
        .style("stroke-width", "2px")
        .style("visibility", "hidden")
        .attr("class", function(d) { return "selector " + d} );

    selection_rectangle.
      on("click", selectRecalc);

// var paths = d3.selectAll("path");
//   for(var key in shuffle(paths[0])) {
//     d3.select(paths[0][key]).transition().duration(1000).delay(key/5).attr("transform", "translate(0)");
//  }



    heatMap.transition().duration(3000).ease("bounce")
        .attr("y", function(d) { return (d.estimator) * gridSize; });

    heatMap
      .on("mouseover", function() { 
          // var stencil = d3.select(".selector." + this.classList[2]);
          // if (typeof prev_stencil == "undefined") {
          //   prev_stencil = stencil
          // };
          // if ( !(stencil.classed("on")) ){
          //   if (stencil != prev_stencil) {
          //     prev_stencil
          //       .transition()
          //       .duration(200)
          //       .style("visibility", "hidden")
          //       .style("stroke", "black");
          //     prev_stencil.classed("temp_on", false);
          //     stencil
          //       .transition()
          //       .duration(200)
          //       .style("visibility", "visible")
          //       .style("stroke", 'purple');
          //     stencil.classed("temp_on", true);
          //   }
          // }
          // prev_stencil = stencil;
      })
      // .on("click", function() {
      //   var selection = ".selector." + this.classList[2];
      //   d3.select(selection).classed("temp_on", false)
      //   d3.select(selection)
      //     .transition()
      //     .duration(200)
      //     .style("visibility", "hidden")
      //     .style("stroke", "black")
      //     .call(selectRecalc);
      // });
      .on("click", selectRecalc);

    function selectRecalc() {
      console.log(this);
      if (d3.select(this).classed("selector")) {
        d3.select(this)
          .transition()
          .duration(500)
          .style("visibility", "hidden");
        var currentRow = this.classList[1];
        d3.selectAll(".box.bordered." + currentRow)
          .classed("selected", false);
        d3.selectAll(".selector." + currentRow)
          .classed("on", false);
        d3.selectAll(".box.bordered")
          .transition()
          .duration(500)
          .style('fill', function(d) {
            if (this.classList.contains(currentRow)) {
              return greyScale(d.value);
            } else if (this.classList.contains("selected")) {
              return colorScale(d.value);
            } else {
              return greyScale(d.value);
            }
          });
        if ( resetGrid(selection_rectangle) ) {
            heatMap
              .transition()
              .duration(500)
              .style("fill", function(d) { return colorScale(d.value); });
        };
      } else {
        d3.select(".selector." + this.classList[2])
          .transition()
          .duration(500)
          .style("visibility", "visible");
        var currentRow = this.classList[2];
        d3.selectAll(".box.bordered." + currentRow)
          .classed("selected", true);
        d3.selectAll(".selector." + currentRow)
          .classed("on", true);
        d3.selectAll('.box.bordered')
          .transition()
          .duration(500)
          .style('fill', function(d) {
            if (this.classList.contains(currentRow)) {
              return colorScale(d.value);
            } else if (this.classList.contains("selected")) {
              return colorScale(d.value);
            } else {
              return greyScale(d.value);
            }
          });
      };
      // recalc colors on each click
    };

    function resetGrid(stencil) {
      var count = 0;
      stencil
        .each( function(x) { 
          test = d3.select(this);
          var status = d3.select(this).classed("on");
          if (status) {
            count += 1;
          }
        })
      return (count == 0);
    };

    heatMap.append("title").text(function(d) { return d.value.toFixed(2) + "%"; });

    var legend = svg.selectAll(".legend")
        .data([0].concat(colorScale.quantiles()), function(d) { return d; })
        .enter().append("g")
          .attr("class", "legend");

    legend.append("rect")
      .attr("x", function(d, i) { return legendElementWidth * i; })
      .attr("y", height)
      .attr("width", legendElementWidth)
      .attr("height", gridSize / 2)
      .style("fill", function(d, i) { return colors[i]; });

    legend.append("text")
      .attr("class", "mono")
      .text(function(d) { return "â‰¥ " + d.toFixed(1) + "%"; })
      .attr("x", function(d, i) { return legendElementWidth * i; })
      .attr("y", height + gridSize);

//     var toolbox_svg = d3.select("#tbox").append("svg")
//       .attr("width", 250 + margin.left + margin.right)
//       .attr("height", 400 + margin.top + margin.bottom)
//       .append("g")
//       .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//     var toolbox = toolbox_svg.selectAll(".tools")
//       .data(data)
//       .enter().append("rect")
//         .attr("class", "tools")
//         .attr("x", width + 100)
//         .attr("y", height + 100)
//         .attr("rx", 4)
//         .attr("ry", 4)
//         .attr("width", 100)
//         .attr("height", 300)
//         .style("fill", "brown");
  }
);

</script>
</body>
</html>