<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <style>
  body {
    font: 10px sans-serif;
  }

  rect.bordered {
    stroke: #E6E6E6;
    stroke-width:2px;   
  }
  .chart {
    position: fixed;
    top: 0px;
    left: 0px;
  }

  .tbox {
    position: fixed;
    top: 0px;
    left: 900px;
    background-color: grey;
    width: 300px;
    height: 500px;
  }

  </style>
  <script src="http://d3js.org/d3.v3.js"></script>
  <script src="http://d3js.org/colorbrewer.v1.min.js"></script>
</head>
<body>
<div class='chart' id="chart"></div>
<div class='tboxx' id="tbox"></div>

<script type="text/javascript">
var margin = { top: 50, right: 0, bottom: 100, left: 100 },
    width = 900 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom,
    gridSize = Math.floor(width / 13),
    legendElementWidth = gridSize*1.3,
    buckets = 70,
    colors = colorbrewer.YlOrRd[9]
    greycolors = colorbrewer.Greys[9]
    estimators = ['linear', 'knn', 'logistic', 'gaussian', 'svc', 'decision tree', 'random forest'],
    features = ['age', 'sex', 'chest pain', 'resting bp', 'cholesterol',
            'blood sugar', 'ecg', 'max hr', 'angina',
            'depression', 'slope', 'vessels', 'thal'],
    ys = ['linear', 'knn', 'logistic', 'gaussian', 'svc', 'decision_tree', 'random_forest'],
    xs = ['age', 'sex', 'chest_pain', 'resting_bp', 'cholesterol',
            'blood_sugar', 'ecg', 'max_hr', 'exercise_induced_angina',
            'st_depression', 'slope', 'num_major_vessels', 'thal'];

d3.tsv("cleveland_data.csv",
  function(d) {
    return {
      estimator: ys.indexOf(d.Estimator),
      feature: xs.indexOf(d.Feature),
      value: +d.Accuracy * 100
    };
  },

  function(error, data) {
    var colorScale = d3.scale.quantile()
        .domain([20, buckets, d3.max(data, function (d) { return d.value; })])
        .range(colors);
    var greyScale = d3.scale.quantile()
        .domain([20, buckets, d3.max(data, function (d) { return d.value; })])
        .range(greycolors);

    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var estimatorLabels = svg.selectAll(".estimatorLabel")
        .data(estimators)
        .enter().append("text")
          .text(function (d) { return d; })
          .attr("x", 0)
          .attr("y", function (d, i) { return i * gridSize; })
          .style("text-anchor", "end")
          .attr("transform", "translate(-6," + gridSize / 1.5 + ")");

    var featureLabels = svg.selectAll(".featureLabel")
        .data(features)
        .enter().append("text")
          .text(function(d) { return d; })
          .attr("x", function(d, i) { return i * gridSize; })
          .attr("y", 0)
          .style("text-anchor", "middle")
          .attr("transform", "translate(" + gridSize / 2 + ", -6)");

    var heatMap = svg.selectAll(".box")
        .data(data)
        .enter().append("rect")
          .attr("x", function(d) { return (d.feature) * gridSize; })
          .attr("y", function(d) { return (d.estimator + 1) * gridSize * -1; })
          // .attr("y", -100)
          .attr("rx", 4)
          .attr("ry", 4)
          .attr("class", function(d) { return "box bordered " + xs[d.feature]} )
          .attr("width", gridSize)
          .attr("height", gridSize)
          .style("fill", function(d) { return colorScale(d.value); });
          // .style("fill", colors[0]);

    var selection_rectangle = svg.selectAll(".selector")
      .data(xs)
      .enter().append("rect")
        .attr("x", function(d, i) { return i * gridSize; })
        .attr("y", -20)
        .attr("rx", 4)
        .attr("ry", 4)
        .attr("width", gridSize)
        .attr("height", 447)
        .attr("opacity", 1.0)
        .attr("stroke-opacity", 0.6)
        .attr("fill-opacity", 0.0)
        .attr("fill", 'purple')
        .attr("stroke", '#000000')
        .attr("stroke-width", "2px")
        .style("visibility", "hidden")
        .attr("class", function(d) { return "selector " + d} );

    selection_rectangle.
      on("click", selectRecalc);

    heatMap.transition().duration(30)
        // .style("fill", function(d) { return colorScale(d.value); })
        .attr("y", function(d) { return (d.estimator) * gridSize; });

    heatMap
      .on("mouseover", function() {
        d3.select(this)
          .transition()
          .duration(200)
          // .attr("width", 10)
          .style("fill", 'purple')
      })
      .on("mouseout", function() {
        d3.select(this)
          .transition()
          .duration(600)
          // .attr("width", gridSize)
          .style("fill", function(d) { return colorScale(d.value); })
      })
      .on("click", selectRecalc);

    function selectRecalc() {
      if (this.classList.contains("selector")) {
        d3.select(this)
          .style("visibility", "hidden");
        d3.selectAll(".box.bordered" + this.classList[1])
          .style("fill", function(d) { return colorScale(d.value); });
      } else {
        d3.select(".selector." + this.classList[2])
          .style("visibility", "visible");
        d3.selectAll(".box.bordered")
          .style("fill", function(d) { return greyScale(d.value); });
      };
      // keep track of whether turned on
      // recalc colors on each click
      // greyshade non clicked colors on
      console.log(this.getAttribute("class"));
      console.log(this.classList[1]);
      console.log(this);
      console.log(this.classList.contains("selector"))
    };

    heatMap.append("title").text(function(d) { return d.value; });

    var legend = svg.selectAll(".legend")
        .data([0].concat(colorScale.quantiles()), function(d) { return d; })
        .enter().append("g")
          .attr("class", "legend");

    legend.append("rect")
      .attr("x", function(d, i) { return legendElementWidth * i; })
      .attr("y", height)
      .attr("width", legendElementWidth)
      .attr("height", gridSize / 2)
      .style("fill", function(d, i) { return colors[i]; });

    legend.append("text")
      .attr("class", "mono")
      .text(function(d) { return "â‰¥ " + d.toFixed(1) + "%"; })
      .attr("x", function(d, i) { return legendElementWidth * i; })
      .attr("y", height + gridSize);

//     var toolbox_svg = d3.select("#tbox").append("svg")
//       .attr("width", 250 + margin.left + margin.right)
//       .attr("height", 400 + margin.top + margin.bottom)
//       .append("g")
//       .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

//     var toolbox = toolbox_svg.selectAll(".tools")
//       .data(data)
//       .enter().append("rect")
//         .attr("class", "tools")
//         .attr("x", width + 100)
//         .attr("y", height + 100)
//         .attr("rx", 4)
//         .attr("ry", 4)
//         .attr("width", 100)
//         .attr("height", 300)
//         .style("fill", "brown");
  }
);

</script>
</body>
</html>